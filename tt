void run_pipex(t_pipex *pipex, char *envp[]) {
    int pipefd[2];
    int prev_fd = -1;  // No pipe before first command

    for (int i = 0; i < pipex->count; i++) {
        // Create pipe only if not the last command
        if (i < pipex->count - 1 && pipe(pipefd) == -1)
            safe_exit(pipex, 1);

        pid_t pid = fork();
        if (pid == -1)
            safe_exit(pipex, 1);

        if (pid == 0) {  // Child process
            // Redirect stdin (first cmd: infile, others: prev_fd)
            if (i == 0)
                dup3(pipex->infile_fd, STDIN_FILENO);
            else
                dup3(prev_fd, STDIN_FILENO);

            // Redirect stdout (last cmd: outfile, others: pipefd[1])
            if (i == pipex->count - 1)
                dup3(pipex->outfile_fd, STDOUT_FILENO);
            else
                dup3(pipefd[1], STDOUT_FILENO);

            // Close all pipe FDs (safety)
            if (prev_fd != -1) close(prev_fd);
            if (i < pipex->count - 1) {
                close(pipefd[0]);
                close(pipefd[1]);
            }

            // Execute command
            get_args(pipex, i);
            child_process(pipex, envp);
        }

        // Parent: close unused FDs and update prev_fd
        if (prev_fd != -1) close(prev_fd);
        if (i < pipex->count - 1) {
            close(pipefd[1]);  // Parent doesn't write to this pipe
            prev_fd = pipefd[0];  // Next command reads from this
        }
    }

    // Parent waits for all children
    while (wait(NULL) != -1);
}